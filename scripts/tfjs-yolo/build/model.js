/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/model-utils/dataset.ts":
/*!************************************!*\
  !*** ./src/model-utils/dataset.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.transform_images = exports.transform_targets_for_output = exports.getSingle = exports.transformTargets = void 0;\nvar loss_1 = __webpack_require__(/*! ./loss */ \"./src/model-utils/loss.ts\");\nvar model_1 = __webpack_require__(/*! ./model */ \"./src/model-utils/model.ts\");\nfunction transformTargets(y_train, anchors, size) {\n    return __awaiter(this, void 0, void 0, function () {\n        var y_outs, grid_size, anchor_area, box_wh, box_area, intersection, iou, anchor_idx, _i, _a, anchor_idxs, _b, _c;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    y_outs = [];\n                    grid_size = Math.floor(size / 32);\n                    anchors = tf.cast(anchors, 'float32');\n                    anchor_area = tf.mul(loss_1.getLastIndex(anchors, 0), loss_1.getLastIndex(anchors, 1));\n                    box_wh = tf.sub(y_train.slice([0, 0, 2], [-1, -1, 2]), y_train.slice([0, 0, 0], [-1, -1, 2]));\n                    box_wh = tf.tile(tf.expandDims(box_wh, -2), [1, 1, anchors.shape[0], 1]);\n                    box_area = tf.mul(loss_1.getLastIndex(box_wh, 0), loss_1.getLastIndex(box_wh, 1));\n                    intersection = tf.mul(tf.minimum(loss_1.getLastIndex(box_wh, 0), loss_1.getLastIndex(anchors, 0)), tf.minimum(loss_1.getLastIndex(box_wh, 1), loss_1.getLastIndex(anchors, 1)));\n                    iou = tf.div(intersection, tf.sub(tf.add(box_area, anchor_area), intersection));\n                    anchor_idx = tf.cast(tf.argMax(iou, -1), 'float32');\n                    anchor_idx = tf.expandDims(anchor_idx, -1);\n                    y_train = tf.concat([y_train, anchor_idx], -1);\n                    _i = 0, _a = model_1.getConstants().yolo_tiny_anchor_masks;\n                    _d.label = 1;\n                case 1:\n                    if (!(_i < _a.length)) return [3 /*break*/, 4];\n                    anchor_idxs = _a[_i];\n                    _c = (_b = y_outs).push;\n                    return [4 /*yield*/, transform_targets_for_output(y_train, grid_size, anchor_idxs)];\n                case 2:\n                    _c.apply(_b, [(_d.sent())]);\n                    grid_size *= 2;\n                    _d.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/, y_outs];\n            }\n        });\n    });\n}\nexports.transformTargets = transformTargets;\nfunction getSingle(x, position) {\n    return x.slice(position, new Array(position.length).fill(1)).reshape([1]);\n}\nexports.getSingle = getSingle;\nfunction transform_targets_for_output(y_true, grid_size, anchor_idxss) {\n    return __awaiter(this, void 0, void 0, function () {\n        var N, y_true_out, anchor_idxs, indexes, updates, i, j, anchor_eq, box, box_xy, anchor_idx, _a, _b, grid_xy, buffer, i, index, update, j;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    N = y_true.shape[0];\n                    y_true_out = tf.zeros([N, grid_size, grid_size, anchor_idxss.length, 6]);\n                    anchor_idxs = tf.tensor(anchor_idxss);\n                    anchor_idxs = tf.cast(anchor_idxs, 'int32');\n                    indexes = [];\n                    updates = [];\n                    i = 0;\n                    _c.label = 1;\n                case 1:\n                    if (!(i < N)) return [3 /*break*/, 6];\n                    j = 0;\n                    _c.label = 2;\n                case 2:\n                    if (!(j < y_true.shape[1])) return [3 /*break*/, 5];\n                    if (tf.equal(getSingle(y_true, [i, j, 2]), 0).dataSync()[0]) {\n                        return [3 /*break*/, 4];\n                    }\n                    anchor_eq = tf.equal(anchor_idxs, tf.cast(getSingle(y_true, [i, j, 5]), 'int32'));\n                    if (!tf.any(anchor_eq).dataSync()[0]) return [3 /*break*/, 4];\n                    box = y_true.slice([i, j, 0], [1, 1, 4]).reshape([4]);\n                    box_xy = tf.div(tf.add(y_true.slice([i, j, 0], [1, 1, 2]).reshape([2]), y_true.slice([i, j, 2], [1, 1, 2]).reshape([2])), 2);\n                    _b = (_a = tf).cast;\n                    return [4 /*yield*/, tf.whereAsync(anchor_eq)];\n                case 3:\n                    anchor_idx = _b.apply(_a, [(_c.sent()), 'int32']);\n                    grid_xy = tf.cast(tf.floorDiv(box_xy, tf.div(1, grid_size)), 'int32');\n                    indexes.push([i, grid_xy.slice([1], [1]).reshape([1]).dataSync()[0], grid_xy.slice([0], [1]).reshape([1]).dataSync()[0], anchor_idx.slice([0, 0], [1, 1]).reshape([1]).dataSync()[0]]);\n                    updates.push([\n                        box.slice([0], [1]).reshape([1]).dataSync()[0],\n                        box.slice([1], [1]).reshape([1]).dataSync()[0],\n                        box.slice([2], [1]).reshape([1]).dataSync()[0],\n                        box.slice([3], [1]).reshape([1]).dataSync()[0],\n                        1,\n                        y_true.slice([i, j, 4], [1, 1, 1]).reshape([1]).dataSync()[0]\n                    ]);\n                    _c.label = 4;\n                case 4:\n                    j++;\n                    return [3 /*break*/, 2];\n                case 5:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 6: return [4 /*yield*/, y_true_out.bufferSync()];\n                case 7:\n                    buffer = _c.sent();\n                    for (i = 0; i < indexes.length; i++) {\n                        index = indexes[i];\n                        update = updates[i];\n                        for (j = 0; j < update.length; j++) {\n                            buffer.set.apply(buffer, __spreadArray([update[j]], (index.concat([j]))));\n                        }\n                    }\n                    return [2 /*return*/, buffer.toTensor()];\n            }\n        });\n    });\n}\nexports.transform_targets_for_output = transform_targets_for_output;\nfunction transform_images(image, size) {\n    return tf.div(tf.image.resizeBilinear(image, size), 255);\n}\nexports.transform_images = transform_images;\n\n\n//# sourceURL=webpack://@ali/alias-odps/./src/model-utils/dataset.ts?");

/***/ }),

/***/ "./src/model-utils/loss.ts":
/*!*********************************!*\
  !*** ./src/model-utils/loss.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lossWrap = exports.getLastIndex = void 0;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/model-utils/utils.ts\");\nfunction _meshgrid(n_a, n_b) {\n    var repeatTensor = [];\n    for (var i = 0; i < n_a; i++) {\n        repeatTensor.push(tf.range(0, n_b));\n    }\n    return [\n        tf.reshape(tf.tile(tf.range(0, n_a), [n_b]), [n_b, n_a]),\n        tf.reshape(tf.stack(repeatTensor), [n_b, n_a])\n    ];\n}\nfunction yolo_boxes(pred, anchors, classes) {\n    var gridSize = pred.shape.slice(1, 3);\n    var _a = tf.split(pred, [2, 2, 1, classes], -1), box_xy = _a[0], box_wh = _a[1], objectness = _a[2], class_probs = _a[3];\n    box_xy = tf.sigmoid(box_xy);\n    objectness = tf.sigmoid(objectness);\n    class_probs = tf.sigmoid(class_probs);\n    var pred_box = tf.concat([box_xy, box_wh], -1);\n    var grid = _meshgrid(gridSize[1], gridSize[0]);\n    grid = tf.expandDims(tf.stack(grid, -1), 2);\n    box_xy = tf.div(tf.add(box_xy, tf.cast(grid, 'float32')), tf.cast(gridSize, 'float32'));\n    box_wh = tf.mul(tf.exp(box_wh), anchors);\n    var box_x1y1 = tf.sub(box_xy, tf.div(box_wh, 2));\n    var box_x2y2 = tf.add(box_xy, tf.div(box_wh, 2));\n    var bbox = tf.concat([box_x1y1, box_x2y2], -1);\n    return [bbox, objectness, class_probs, pred_box];\n}\nfunction broadcast_dynamic_shape(shape1, shape2) {\n    var arr = [];\n    var lengthMax = Math.max(shape1.length, shape2.length);\n    shape1 = (new Array(lengthMax - shape1.length).fill(-1)).concat(shape1);\n    shape2 = (new Array(lengthMax - shape2.length).fill(-1)).concat(shape2);\n    for (var i = 0; i < lengthMax; i++) {\n        if (shape1[i] == 0 || shape2[i] == 0) {\n            arr[i] = 0;\n            continue;\n        }\n        arr[i] = Math.max(shape1[i], shape2[i]);\n    }\n    return arr;\n}\nfunction getLastIndex(arr, num) {\n    var shape = arr.shape;\n    var one = new Array(shape.length).fill(0);\n    one[one.length - 1] = num;\n    var two = new Array(shape.length).fill(-1);\n    two[two.length - 1] = 1;\n    return arr.slice(one, two).reshape(arr.shape.slice(0, arr.shape.length - 1));\n}\nexports.getLastIndex = getLastIndex;\nfunction broadcast_iou(box_1, box_2) {\n    var originShapeFirst = box_2.shape[0];\n    box_1 = tf.expandDims(box_1, -2);\n    box_2 = tf.expandDims(box_2, 0);\n    var new_shape = broadcast_dynamic_shape(box_1.shape, box_2.shape);\n    if (originShapeFirst == 0) {\n        return tf.tensor([], new_shape.slice(0, new_shape.length - 1));\n    }\n    box_1 = tf.broadcastTo(box_1, new_shape);\n    box_2 = tf.broadcastTo(box_2, new_shape);\n    var int_w = tf.maximum(tf.sub(tf.minimum(getLastIndex(box_1, 2), getLastIndex(box_2, 2)), tf.maximum(getLastIndex(box_1, 0), getLastIndex(box_2, 0))), 0);\n    var int_h = tf.maximum(tf.sub(tf.minimum(getLastIndex(box_1, 3), getLastIndex(box_2, 3)), tf.maximum(getLastIndex(box_1, 1), getLastIndex(box_2, 1))), 0);\n    var int_area = tf.mul(int_w, int_h);\n    var box_1_area = tf.mul(tf.sub(getLastIndex(box_1, 2), getLastIndex(box_1, 0)), tf.sub(getLastIndex(box_1, 3), getLastIndex(box_1, 1)));\n    var box_2_area = tf.mul(tf.sub(getLastIndex(box_2, 2), getLastIndex(box_2, 0)), tf.sub(getLastIndex(box_2, 3), getLastIndex(box_2, 1)));\n    return tf.div(int_area, tf.sub(tf.add(box_1_area, box_2_area), int_area));\n}\nfunction lossWrap(anchors, classes, ignore_thresh) {\n    if (ignore_thresh === void 0) { ignore_thresh = 0.5; }\n    return function yoloLoss(yTrue, yPred) {\n        var loss = tf.tidy(function () {\n            var _a = yolo_boxes(yPred, anchors, classes), pred_box = _a[0], pred_obj = _a[1], pred_class = _a[2], pred_xywh = _a[3];\n            var pred_xy = pred_xywh.slice([0, 0, 0, 0, 0], [-1, -1, -1, -1, 2]);\n            var pred_wh = pred_xywh.slice([0, 0, 0, 0, 2], [-1, -1, -1, -1, 2]);\n            var _b = tf.split(yTrue, [4, 1, 1], -1), true_box = _b[0], true_obj = _b[1], true_class_idx = _b[2];\n            var trueBox02 = true_box.slice([0, 0, 0, 0, 0], [-1, -1, -1, -1, 2]);\n            var trueBox24 = true_box.slice([0, 0, 0, 0, 2], [-1, -1, -1, -1, 2]);\n            var true_xy = tf.div(tf.add(trueBox02, trueBox24), 2);\n            var true_wh = tf.sub(trueBox24, trueBox02);\n            var true_wh0 = true_wh.slice([0, 0, 0, 0, 0], [-1, -1, -1, -1, 1]).reshape(true_wh.shape.slice(0, 4));\n            var true_wh1 = true_wh.slice([0, 0, 0, 0, 1], [-1, -1, -1, -1, 1]).reshape(true_wh.shape.slice(0, 4));\n            var box_loss_scale = tf.sub(2, tf.mul(true_wh0, true_wh1));\n            var grid_size = yTrue.shape[1];\n            var gridA = tf.meshgrid(tf.range(0, grid_size), tf.range(0, grid_size));\n            var grid = tf.expandDims(tf.stack(gridA, -1), 2);\n            true_xy = tf.sub(tf.mul(true_xy, tf.cast(grid_size, 'float32')), tf.cast(grid, 'float32'));\n            true_wh = tf.log(tf.div(true_wh, anchors));\n            true_wh = tf.where(tf.isInf(true_wh), tf.zerosLike(true_wh), true_wh);\n            true_wh = tf.where(tf.isNaN(true_wh), tf.zerosLike(true_wh), true_wh);\n            var obj_mask = tf.squeeze(true_obj, [-1]);\n            var best_iou_arr = [];\n            for (var i = 0; i < pred_box.shape[0]; i++) {\n                var cur_pred_box = pred_box.slice([i], [1]).reshape(pred_box.shape.slice(1));\n                var cur_true_box = true_box.slice([i], [1]).reshape(true_box.shape.slice(1));\n                var cur_obj_mask = obj_mask.slice([i], [1]).reshape(obj_mask.shape.slice(1));\n                var boolean_mask = broadcast_iou(cur_pred_box, utils_1.booleanMask(cur_true_box, tf.cast(cur_obj_mask, 'bool')));\n                var reduceMax = tf.max(boolean_mask, -1);\n                best_iou_arr.push(reduceMax);\n            }\n            var best_iou = tf.stack(best_iou_arr);\n            var ignore_mask = tf.cast(tf.cast(tf.sub(tf.minimum(best_iou, ignore_thresh), ignore_thresh), 'bool'), 'float32');\n            var xy_loss = tf.mul(tf.mul(obj_mask, box_loss_scale), tf.sum(tf.square(tf.sub(true_xy, pred_xy)), -1));\n            var wh_loss = tf.mul(tf.mul(obj_mask, box_loss_scale), tf.sum(tf.square(tf.sub(true_wh, pred_wh)), -1));\n            var obj_loss = tf.metrics.binaryCrossentropy(true_obj, pred_obj);\n            obj_loss = tf.add(tf.mul(obj_mask, obj_loss), tf.mul(tf.mul(tf.sub(1, obj_mask), ignore_mask), obj_loss));\n            var class_loss = tf.mul(obj_mask, utils_1.sparseCategoricalCrossentropy(true_class_idx, pred_class));\n            xy_loss = tf.sum(xy_loss, [1, 2, 3]);\n            wh_loss = tf.sum(wh_loss, [1, 2, 3]);\n            obj_loss = tf.sum(obj_loss, [1, 2, 3]);\n            class_loss = tf.sum(class_loss, [1, 2, 3]);\n            return tf.sum(tf.add(tf.add(tf.add(xy_loss, wh_loss), obj_loss), class_loss));\n        });\n        return loss;\n    };\n}\nexports.lossWrap = lossWrap;\n\n\n//# sourceURL=webpack://@ali/alias-odps/./src/model-utils/loss.ts?");

/***/ }),

/***/ "./src/model-utils/model.ts":
/*!**********************************!*\
  !*** ./src/model-utils/model.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tinyYoloBody = exports.getConstants = void 0;\nfunction getConstants() {\n    var yolo_tiny_anchors1 = tf.div(tf.tensor([\n        [81, 82], [135, 169], [344, 319]\n    ], [3, 2], 'float32'), 416);\n    var yolo_tiny_anchors2 = tf.div(tf.tensor([[10, 14], [23, 27], [37, 58]], [3, 2], 'float32'), 416);\n    var yolo_tiny_anchor_masks = [[3, 4, 5], [0, 1, 2]];\n    var yolo_tiny_anchors = tf.div(tf.tensor([[10, 14], [23, 27], [37, 58],\n        [81, 82], [135, 169], [344, 319]], [6, 2], 'float32'), 416);\n    return {\n        yolo_tiny_anchors1: yolo_tiny_anchors1,\n        yolo_tiny_anchors2: yolo_tiny_anchors2,\n        yolo_tiny_anchor_masks: yolo_tiny_anchor_masks,\n        yolo_tiny_anchors: yolo_tiny_anchors\n    };\n}\nexports.getConstants = getConstants;\nfunction DarknetConv2D_BN_Leaky(input, filters, kernelSize) {\n    var temp = tf.layers.conv2d({\n        filters: filters,\n        kernelSize: kernelSize,\n        useBias: false,\n        kernelRegularizer: tf.regularizers.l2({\n            l2: 5e-4\n        }),\n        padding: 'same'\n    }).apply(input);\n    temp = tf.layers.batchNormalization().apply(temp);\n    temp = tf.layers.leakyReLU({\n        alpha: 0.1\n    }).apply(temp);\n    return temp;\n}\nfunction DarknetConv2D(input, filters, kernelSize) {\n    var temp = tf.layers.conv2d({\n        filters: filters,\n        kernelSize: kernelSize,\n        kernelRegularizer: tf.regularizers.l2({\n            l2: 5e-4\n        }),\n        padding: 'same'\n    }).apply(input);\n    return temp;\n}\nfunction maxPooling2d(input, poolSize, strides) {\n    var temp = tf.layers.maxPooling2d({\n        poolSize: poolSize,\n        strides: strides,\n        padding: 'same'\n    }).apply(input);\n    return temp;\n}\nfunction DarknetTiny(name) {\n    if (name === void 0) { name = ''; }\n    var inputs = tf.layers.input({\n        shape: [null, null, 3]\n    });\n    var temp = inputs;\n    temp = DarknetConv2D_BN_Leaky(temp, 16, [3, 3]);\n    temp = maxPooling2d(temp, [2, 2], [2, 2]);\n    temp = DarknetConv2D_BN_Leaky(temp, 32, [3, 3]);\n    temp = maxPooling2d(temp, [2, 2], [2, 2]);\n    temp = DarknetConv2D_BN_Leaky(temp, 64, [3, 3]);\n    temp = maxPooling2d(temp, [2, 2], [2, 2]);\n    temp = DarknetConv2D_BN_Leaky(temp, 128, [3, 3]);\n    temp = maxPooling2d(temp, [2, 2], [2, 2]);\n    temp = DarknetConv2D_BN_Leaky(temp, 256, [3, 3]);\n    var x1 = temp;\n    temp = maxPooling2d(temp, [2, 2], [2, 2]);\n    temp = DarknetConv2D_BN_Leaky(temp, 512, [3, 3]);\n    temp = maxPooling2d(temp, [2, 2], [1, 1]);\n    temp = DarknetConv2D_BN_Leaky(temp, 1024, [3, 3]);\n    return tf.model({\n        inputs: inputs,\n        outputs: [x1, temp],\n        name: name\n    });\n}\nfunction YoloConvTiny(filters, x_in, name) {\n    if (name === void 0) { name = ''; }\n    var x;\n    var inputs;\n    if (Array.isArray(x_in)) {\n        inputs = [tf.layers.input({\n                shape: x_in[0].shape.slice(1)\n            }), tf.layers.input({\n                shape: x_in[1].shape.slice(1)\n            })];\n        x = inputs[0];\n        var x_skip = inputs[1];\n        x = DarknetConv2D_BN_Leaky(x, filters, [1, 1]);\n        x = tf.layers.upSampling2d({\n            size: [2, 2]\n        }).apply(x);\n        x = tf.layers.concatenate().apply([x, x_skip]);\n    }\n    else {\n        x = tf.layers.input({\n            shape: x_in.shape.slice(1)\n        });\n        inputs = x;\n        x = DarknetConv2D_BN_Leaky(x, filters, [1, 1]);\n    }\n    return tf.model({\n        inputs: inputs,\n        outputs: x,\n        name: name\n    }).apply(x_in);\n}\nfunction YoloOutput(x_in, filters, anchors, numClasses, name) {\n    if (name === void 0) { name = ''; }\n    var x = tf.layers.input({\n        shape: x_in.shape.slice(1)\n    });\n    var inputs = x;\n    x = DarknetConv2D_BN_Leaky(x, filters * 2, [3, 3]);\n    x = DarknetConv2D(x, anchors * (numClasses + 5), [1, 1]);\n    x = tf.layers.reshape({\n        targetShape: [x.shape[1], x.shape[2], anchors, numClasses + 5]\n    }).apply(x);\n    return tf.model({\n        inputs: inputs,\n        outputs: x,\n        name: name\n    });\n}\nfunction tinyYoloBody(imageInput, anchors, numClasses) {\n    var _a = DarknetTiny('yolo_darknet').apply(imageInput), x_8 = _a[0], x = _a[1];\n    x = YoloConvTiny(256, x, 'yolo_conv_0');\n    var output_0 = YoloOutput(x, 256, anchors, numClasses, 'yolo_output_0').apply(x);\n    x = YoloConvTiny(128, [x, x_8], 'yolo_conv_1');\n    var output_1 = YoloOutput(x, 128, anchors, numClasses, 'yolo_output_1').apply(x);\n    return tf.model({\n        inputs: imageInput,\n        outputs: [output_0, output_1]\n    });\n}\nexports.tinyYoloBody = tinyYoloBody;\n\n\n//# sourceURL=webpack://@ali/alias-odps/./src/model-utils/model.ts?");

/***/ }),

/***/ "./src/model-utils/utils.ts":
/*!**********************************!*\
  !*** ./src/model-utils/utils.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sparseCategoricalCrossentropy = exports.sigmoidCrossEntropyWithLogits = exports.booleanMask = void 0;\nfunction whereImpl(condShape, condVals) {\n    var indices = [];\n    for (var i = 0; i < condVals.length; i++) {\n        if (condVals[i]) {\n            indices.push(i);\n        }\n    }\n    var inBuffer = global.tf.buffer(condShape, 'int32');\n    var out = tf.buffer([indices.length, condShape.length], 'int32');\n    for (var i = 0; i < indices.length; i++) {\n        var loc = inBuffer.indexToLoc(indices[i]);\n        var offset = i * condShape.length;\n        out.values.set(loc, offset);\n    }\n    return out.toTensor();\n}\nfunction where(condition) {\n    var vals = condition.dataSync();\n    var res = whereImpl(condition.shape, vals);\n    return res;\n}\nfunction booleanMask(tensor, mask, axis) {\n    var $tensor = tensor;\n    var $mask = mask;\n    var axisFrom = axis == null ? 0 : axis;\n    var maskDim = $mask.rank;\n    var tensorShape = $tensor.shape;\n    var leadingSize = 1;\n    for (var i = axisFrom; i < axisFrom + maskDim; i++) {\n        leadingSize *= tensorShape[i];\n    }\n    var targetTensorShape = tensorShape.slice(0, axisFrom)\n        .concat([leadingSize], tensorShape.slice(axisFrom + maskDim));\n    var reshapedTensor = tf.reshape($tensor, targetTensorShape);\n    var reshapedMask = tf.reshape($mask, [-1]);\n    var positivePositions = where(reshapedMask);\n    var indices = tf.squeeze(positivePositions, [1]);\n    var res = tf.gather(reshapedTensor, indices, axisFrom);\n    // Ensure no memory leak.\n    if (tensor !== $tensor) {\n        $tensor.dispose();\n    }\n    if (mask !== $mask) {\n        $mask.dispose();\n    }\n    indices.dispose();\n    reshapedTensor.dispose();\n    reshapedMask.dispose();\n    positivePositions.dispose();\n    return res;\n}\nexports.booleanMask = booleanMask;\nfunction sigmoidCrossEntropyWithLogits(labels, logits) {\n    var $labels = labels;\n    var $logits = logits;\n    var maxOutput = tf.relu($logits);\n    var outputXTarget = tf.mul($logits, $labels);\n    var sigmoidOutput = tf.log1p(tf.exp(tf.neg(tf.abs($logits))));\n    return tf.add(tf.sub(maxOutput, outputXTarget), sigmoidOutput);\n}\nexports.sigmoidCrossEntropyWithLogits = sigmoidCrossEntropyWithLogits;\nfunction sparseCategoricalCrossentropy(target, output) {\n    var flatTarget = tf.floor(tf.reshape(target, [-1])).toInt();\n    output = tf.clipByValue(output, tf.backend().epsilon(), 1 - tf.backend().epsilon());\n    var outputShape = output.shape;\n    var oneHotTarget;\n    if (outputShape[outputShape.length - 1] > 1) {\n        oneHotTarget =\n            tf.oneHot(flatTarget, outputShape[outputShape.length - 1])\n                .reshape(outputShape);\n    }\n    else {\n        oneHotTarget = flatTarget.reshape(outputShape);\n    }\n    return tf.metrics.categoricalCrossentropy(oneHotTarget, output);\n}\nexports.sparseCategoricalCrossentropy = sparseCategoricalCrossentropy;\n\n\n//# sourceURL=webpack://@ali/alias-odps/./src/model-utils/utils.ts?");

/***/ }),

/***/ "./src/model.ts":
/*!**********************!*\
  !*** ./src/model.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar model_1 = __webpack_require__(/*! ./model-utils/model */ \"./src/model-utils/model.ts\");\nvar loss_1 = __webpack_require__(/*! ./model-utils/loss */ \"./src/model-utils/loss.ts\");\nvar dataset_1 = __webpack_require__(/*! ./model-utils/dataset */ \"./src/model-utils/dataset.ts\");\nfunction getAnchors() {\n    return tf.tensor([[10, 14], [23, 27], [37, 58], [81, 82], [135, 169], [344, 319]], [6, 2], 'float32');\n}\nfunction transformBBox(bboxes, width, height, labelIds) {\n    var res = bboxes.map(function (bbox, index) {\n        bbox.forEach(function (box, index2) {\n            box[2] = box[0] + box[2];\n            box[3] = box[1] + box[3];\n            box[0] = box[0] / width;\n            box[1] = box[1] / height;\n            box[2] = box[2] / width;\n            box[3] = box[3] / height;\n            box[4] = labelIds[index][index2];\n        });\n        bbox = bbox.slice(0, 8);\n        if (bbox.length < 8) {\n            bbox = bbox.concat(new Array(8 - bbox.length).fill([0, 0, 0, 0, 0]));\n        }\n        return bbox;\n    });\n    return res;\n}\nfunction createTinyModel(inputShape, anchors, numClasses, freezeBody) {\n    var imageInput = tf.input({\n        shape: [inputShape[0], inputShape[1], 3]\n    });\n    var modelBody = model_1.tinyYoloBody(imageInput, 3, numClasses);\n    return modelBody;\n}\nvar main = function (api, options, context) { return __awaiter(void 0, void 0, void 0, function () {\n    var modelDir, _a, epochs, _b, batchSize, tf, _c, dataset, meta, trainSize, batchesPerEpoch, numClasses, anchors, freezeBody, inputShape, model, loss, i, _loop_1, j;\n    return __generator(this, function (_d) {\n        switch (_d.label) {\n            case 0:\n                modelDir = context.workspace.modelDir;\n                _a = options.epochs, epochs = _a === void 0 ? 10 : _a, _b = options.batchSize, batchSize = _b === void 0 ? 16 : _b;\n                _d.label = 1;\n            case 1:\n                _d.trys.push([1, 3, , 5]);\n                return [4 /*yield*/, context.importJS('@tensorflow/tfjs-node-gpu')];\n            case 2:\n                tf = _d.sent();\n                return [3 /*break*/, 5];\n            case 3:\n                _c = _d.sent();\n                return [4 /*yield*/, context.importJS('@tensorflow/tfjs-node')];\n            case 4:\n                tf = _d.sent();\n                return [3 /*break*/, 5];\n            case 5:\n                global.tf = tf;\n                dataset = api.dataset;\n                return [4 /*yield*/, dataset.getDatasetMeta()];\n            case 6:\n                meta = _d.sent();\n                trainSize = meta.size.train;\n                batchesPerEpoch = Math.floor(trainSize / batchSize);\n                numClasses = Object.keys(meta.labelMap).length;\n                anchors = getAnchors();\n                freezeBody = true;\n                inputShape = [416, 416];\n                model = createTinyModel(inputShape, anchors, numClasses, freezeBody);\n                loss = [\n                    loss_1.lossWrap(model_1.getConstants().yolo_tiny_anchors1, numClasses),\n                    loss_1.lossWrap(model_1.getConstants().yolo_tiny_anchors2, numClasses)\n                ];\n                model.compile({\n                    optimizer: tf.train.adam(1e-3),\n                    loss: loss\n                });\n                i = 0;\n                _d.label = 7;\n            case 7:\n                if (!(i < epochs)) return [3 /*break*/, 13];\n                console.log(\"Epoch \" + i + \"/\" + epochs + \" start\");\n                return [4 /*yield*/, dataset.train.seek(0)];\n            case 8:\n                _d.sent();\n                _loop_1 = function (j) {\n                    var dataBatch, xs, ys, yss, res;\n                    return __generator(this, function (_e) {\n                        switch (_e.label) {\n                            case 0: return [4 /*yield*/, dataset.train.nextBatch(batchSize)];\n                            case 1:\n                                dataBatch = _e.sent();\n                                xs = tf.tidy(function () { return tf.stack(dataBatch.map(function (ele) { return ele.data; })); });\n                                ys = tf.tidy(function () {\n                                    var bboxes = dataBatch.map(function (ele) { return ele.label.map(function (ele2) { return ele2.bbox; }); });\n                                    var labels = dataBatch.map(function (ele) { return ele.label.map(function (ele2) { return Number(ele2.category_id) - 1; }); });\n                                    bboxes = transformBBox(bboxes, meta.dimension.x, meta.dimension.y, labels);\n                                    var ys = tf.tensor(bboxes);\n                                    return ys;\n                                });\n                                return [4 /*yield*/, dataset_1.transformTargets(ys, model_1.getConstants().yolo_tiny_anchors, 416)];\n                            case 2:\n                                yss = (_e.sent());\n                                return [4 /*yield*/, model.trainOnBatch()];\n                            case 3:\n                                res = _e.sent();\n                                if (j % (Math.floor(batchesPerEpoch / 10)) === 0) {\n                                    console.log(\"epoch \" + i + \" - iteration \" + j + \": total loss is \" + res[0]);\n                                }\n                                return [2 /*return*/];\n                        }\n                    });\n                };\n                j = 0;\n                _d.label = 9;\n            case 9:\n                if (!(j < batchesPerEpoch)) return [3 /*break*/, 12];\n                return [5 /*yield**/, _loop_1(j)];\n            case 10:\n                _d.sent();\n                _d.label = 11;\n            case 11:\n                j++;\n                return [3 /*break*/, 9];\n            case 12:\n                i++;\n                return [3 /*break*/, 7];\n            case 13: return [4 /*yield*/, model.save(\"file://\" + modelDir)];\n            case 14:\n                _d.sent();\n                return [2 /*return*/];\n        }\n    });\n}); };\nexports.default = main;\n\n\n//# sourceURL=webpack://@ali/alias-odps/./src/model.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/model.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});